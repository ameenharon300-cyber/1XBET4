// ===================================================
// ğŸš€ AI GOAL PREDICTOR ULTIMATE - VERSION 10.4
// ğŸ‘¤ DEVELOPER: AMIN - @GEMZGOOLBOT
// ğŸ”¥ FEATURES: SMART AI + BETTING SYSTEM + FIREBASE + FULL ADMIN PANEL
// ===================================================

console.log('ğŸ¤– Starting AI GOAL Predictor Ultimate v10.4...');
console.log('ğŸ•’ ' + new Date().toISOString());

// ğŸ”§ CONFIGURATION
const CONFIG = {
    BOT_TOKEN: process.env.BOT_TOKEN || "8125363786:AAFZaOGSAvq_p8Sc8cq2bIKZlpe4ej7tmdU",
    ADMIN_ID: process.env.ADMIN_ID || "6565594143",
    
    // ğŸ§  AI APIS
    AI_APIS: {
        GEMINI: process.env.GEMINI_API_KEY || "AIzaSyCtjtT98-M5v6t8qICPSDw-1TLwPneyaQc",
        OPENAI: process.env.OPENAI_API_KEY || "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"
    },

    // ğŸ’° DEFAULT PRICING
    SUBSCRIPTION_PRICES: {
        week: 10,
        month: 30,
        three_months: 80,
        year: 250
    },

    // ğŸ” DEFAULT PAYMENT LINKS
    PAYMENT_LINKS: {
        week: process.env.PAYMENT_WEEK || "https://binance.com/payment/weekly",
        month: process.env.PAYMENT_MONTH || "https://binance.com/payment/monthly", 
        three_months: process.env.PAYMENT_3MONTHS || "https://binance.com/payment/3months",
        year: process.env.PAYMENT_YEAR || "https://binance.com/payment/yearly"
    },
    
    VERSION: "10.4.0",
    DEVELOPER: "AMIN - @GEMZGOOLBOT",
    CHANNEL: "@GEMZGOOL",
    START_IMAGE: "https://i.ibb.co/tpy70Bd1/IMG-20251104-074214-065.jpg",
    ANALYSIS_IMAGE: "https://i.ibb.co/VYjf05S0/Screenshot.png",
    IMGBB_API_KEY: "42b155a527bee21e62e524a31fe9b1ee"
};

console.log('âœ… Configuration loaded successfully');

// ğŸš€ INITIALIZE BOT
const { Telegraf, Markup, session } = require('telegraf');
const axios = require('axios');

const fetch = require('node-fetch');

/**
 * callVisionAPI(imageUrl)
 * Uses Google Vision REST API to get labels and OCR text.
 * Requires CONFIG.AI_APIS.GEMINI or CONFIG.AI_APIS.GOOGLE_VISION_KEY to be set.
 */
async function callVisionAPI(imageUrl) {
    const apiKey = CONFIG.AI_APIS && (CONFIG.AI_APIS.GEMINI || CONFIG.AI_APIS.GOOGLE_VISION_KEY);
    if (!apiKey) return null;
    try {
        // fetch image as arraybuffer and convert to base64
        const res = await axios.get(imageUrl, { responseType: 'arraybuffer' });
        const base64 = Buffer.from(res.data, 'binary').toString('base64');
        const body = {
            requests: [
                {
                    image: { content: base64 },
                    features: [
                        { type: "LABEL_DETECTION", maxResults: 20 },
                        { type: "TEXT_DETECTION", maxResults: 50 },
                        { type: "OBJECT_LOCALIZATION", maxResults: 20 },
                        { type: "FACE_DETECTION", maxResults: 10 }
                    ]
                }
            ]
        };
        const visionUrl = `https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`;
        const visionRes = await fetch(visionUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body)
        });
        const json = await visionRes.json();
        return json;
    } catch (err) {
        console.error('callVisionAPI error:', err && err.message ? err.message : err);
        return null;
    }
}
const express = require('express');
const FormData = require('form-data');

const bot = new Telegraf(CONFIG.BOT_TOKEN);

// ğŸŒ HEALTH CHECK SERVER FOR REPLIT
const app = express();
const PORT = process.env.PORT || 3000;

app.get('/', (req, res) => {
    res.json({ 
        status: 'OK', 
        version: CONFIG.VERSION,
        timestamp: new Date().toISOString(),
        message: 'AI Goal Predictor Bot is running...',
        developer: CONFIG.DEVELOPER
    });
});

app.listen(PORT, () => {
    console.log(`ğŸŒ Health check server running on port ${PORT}`);
});

// ğŸ”¥ FIREBASE INITIALIZATION
let db = null;
let admin = null;

try {
    admin = require('firebase-admin');
    
    const serviceAccount = {
        "type": "service_account",
        "project_id": "bot-tlegram-9f4b5",
        "private_key_id": process.env.FIREBASE_PRIVATE_KEY_ID || "private_key_id",
        "private_key": process.env.FIREBASE_PRIVATE_KEY ? process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n') : "-----BEGIN PRIVATE KEY-----\nMIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCqM3Q...\n-----END PRIVATE KEY-----\n",
        "client_email": process.env.FIREBASE_CLIENT_EMAIL || "firebase-adminsdk@bot-tlegram-9f4b5.iam.gserviceaccount.com",
        "client_id": process.env.FIREBASE_CLIENT_ID || "client_id",
        "auth_uri": "https://accounts.google.com/o/oauth2/auth",
        "token_uri": "https://oauth2.googleapis.com/token",
        "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
        "client_x509_cert_url": process.env.FIREBASE_CERT_URL || "https://www.googleapis.com/robot/v1/metadata/x509/firebase-adminsdk%40bot-tlegram-9f4b5.iam.gserviceaccount.com"
    };

    if (!admin.apps.length) {
        admin.initializeApp({
            credential: admin.credential.cert(serviceAccount),
            databaseURL: "https://bot-tlegram-9f4b5-default-rtdb.firebaseio.com"
        });
    }
    
    db = admin.firestore();
    console.log('âœ… Firebase initialized successfully');
    
} catch (error) {
    console.log('âš ï¸ Firebase initialization failed:', error.message);
    console.log('ğŸ”„ Using local storage instead');
}

// ğŸ—„ï¸ LOCAL STORAGE FALLBACK
const userDatabase = new Map();
const paymentDatabase = new Map();
const settingsDatabase = new Map();

// ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
settingsDatabase.set('config', {
    prices: { ...CONFIG.SUBSCRIPTION_PRICES },
    payment_links: { ...CONFIG.PAYMENT_LINKS },
    maintenance_mode: false,
    updated_at: new Date().toISOString()
});

// ğŸ“Š FAKE STATISTICS SYSTEM
class FakeStatistics {
    constructor() {
        this.totalUsers = 78542;
        this.activeUsers = 287;
    }

    getStats() {
        return {
            totalUsers: this.totalUsers,
            activeUsers: this.activeUsers
        };
    }
}

// ğŸ§  SMART GOAL PREDICTION ENGINE
class GoalPredictionAI {
    constructor() {
        this.algorithmVersion = "10.4";
    }

    generateSmartPrediction(userId) {
        const isGoal = Math.random() > 0.5;
        const probability = Math.floor(Math.random() * 30) + 60;
        
        const prediction = {
            type: isGoal ? 'âš½ Ù‡Ø¯Ù Ù…Ø¤ÙƒØ¯' : 'ğŸ›¡ï¸ Ø¯ÙØ§Ø¹ Ù‚ÙˆÙŠ',
            probability: probability,
            confidence: 100,
            reasoning: isGoal ? 
                `ğŸ”¥ Ø§Ù„Ø¶ØºØ· Ø§Ù„Ù‡Ø¬ÙˆÙ…ÙŠ Ø§Ù„Ù…Ø³ØªÙ…Ø± ÙŠØ´ÙŠØ± Ù„Ù‡Ø¯Ù Ù‚Ø±ÙŠØ¨ Ø¨Ù†Ø³Ø¨Ø© ${probability}%` :
                `ğŸ›¡ï¸ Ø§Ù„Ø¯ÙØ§Ø¹ Ø§Ù„Ù…Ù†Ø¸Ù… ÙŠØ­Ø¯ Ù…Ù† Ø§Ù„ÙØ±Øµ Ø¨Ù†Ø³Ø¨Ø© ${probability}%`,
            timestamp: new Date().toISOString(),
            algorithm: this.algorithmVersion
        };

        return prediction;
    }

    
async analyzeImageWithAI(imageUrl) {
    try {
        // try Vision API first
        const visionResult = await callVisionAPI(imageUrl);

        if (!visionResult || !visionResult.responses || !visionResult.responses[0]) {
            // fallback to smart random predictor
            return this.generateSmartPrediction('image_analysis');
        }

        const resp = visionResult.responses[0];
        const labels = (resp.labelAnnotations || []).map(l => (l.description || '').toLowerCase());
        const texts = (resp.textAnnotations || []).map(t => (t.description || '').toLowerCase());
        const fullText = texts.join(' ').toLowerCase();

        const hasMessi = labels.some(l => l.includes('messi')) || fullText.includes('Ù…ÙŠØ³ÙŠ') || fullText.includes('messi');
        const hasRonaldo = labels.some(l => l.includes('ronaldo')) || fullText.includes('Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ') || fullText.includes('ronaldo');
        const hasNeymar = labels.some(l => l.includes('neymar')) || fullText.includes('Ù†ÙŠÙ…Ø§Ø±') || fullText.includes('neymar');

        const hasGoal = fullText.includes('Ù‡Ø¯Ù') || fullText.includes('goal') || fullText.includes('gool');
        const hasNoGoal = fullText.includes('Ù„Ø§ Ù‡Ø¯Ù') || fullText.includes('no goal') || fullText.includes('no-goal') || fullText.includes('no_goal');
        const hasGoolWord = fullText.includes('gool') || fullText.includes('goal');
        const hasBetButton = fullText.includes('ÙˆØ¶Ø¹ Ø§Ù„Ø±Ù‡Ø§Ù†') || fullText.includes('ÙˆØ¶Ø¹') || fullText.includes('Ø±Ù‡Ø§Ù†') || fullText.includes('bet') || fullText.includes('$');

        const playersCondition = hasMessi && (hasNeymar || hasRonaldo);
        const accepted = playersCondition && hasGoal && hasNoGoal && hasGoolWord && hasBetButton;

        if (accepted) {
            return {
                accepted: true,
                type: (Math.random() > 0.5) ? 'âš½ Ù‡Ø¯Ù Ù…Ø­ØªÙ…Ù„' : 'ğŸ›¡ï¸ Ø¯ÙØ§Ø¹ Ù…Ø­ØªÙ…Ù„',
                probability: Math.floor(Math.random() * 30) + 60,
                confidence: 95,
                reasoning: 'Ø§Ù„ØµÙˆØ±Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ù…ÙŠØ³ÙŠ Ù…Ø¹ Ù„Ø§Ø¹Ø¨ Ø¢Ø®Ø±ØŒ ÙˆØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØµÙˆØµ Ø§Ù„Ø£Ø²Ø±Ø§Ø± ÙˆØ§Ø³Ù… GOOL ÙˆØ²Ø± Ø§Ù„Ø±Ù‡Ø§Ù†.',
                timestamp: new Date().toISOString(),
                algorithm: this.algorithmVersion
            };
        } else {
            return {
                accepted: false,
                reason: 'Ø§Ù„Ø´Ø±ÙˆØ· (Ù„Ø§Ø¹Ø¨ÙŠÙ†/Ù†ØµÙˆØµ/Ø£Ø²Ø±Ø§Ø±) ØºÙŠØ± Ù…ÙƒØªÙ…Ù„Ø©',
                detected: {
                    hasMessi, hasRonaldo, hasNeymar, hasGoal, hasNoGoal, hasGoolWord, hasBetButton, labels, fullTextSnippet: fullText.slice(0, 400)
                },
                timestamp: new Date().toISOString()
            };
        }
    } catch (error) {
        console.error('GoalPredictionAI.analyzeImageWithAI error:', error);
        return this.generateSmartPrediction('fallback');
    }
}
    generateNextPrediction(userId) {
        return this.generateSmartPrediction(userId);
    }
}

// ğŸ“¤ IMGBB UPLOADER
class ImgBBUploader {
    constructor(apiKey) {
        this.apiKey = apiKey;
    }

    async uploadImage(imageUrl) {
        try {
            await new Promise(resolve => setTimeout(resolve, 1000));
            return {
                success: true,
                url: imageUrl,
                delete_url: imageUrl
            };
        } catch (error) {
            return {
                success: false,
                error: error.message
            };
        }
    }
}

// ğŸ’¾ DATABASE MANAGER
class DatabaseManager {
    constructor() {
        this.maintenanceMode = false;
    }

    async getUser(userId) {
        try {
            if (db) {
                const userDoc = await db.collection('users').doc(userId.toString()).get();
                return userDoc.exists ? userDoc.data() : null;
            }
            return userDatabase.get(userId) || null;
        } catch (error) {
            return userDatabase.get(userId) || null;
        }
    }

    async saveUser(userId, userData) {
        try {
            if (db) {
                await db.collection('users').doc(userId.toString()).set(userData, { merge: true });
            }
            userDatabase.set(userId, userData);
            return true;
        } catch (error) {
            userDatabase.set(userId, userData);
            return true;
        }
    }

    async addPayment(paymentData) {
        const paymentId = Date.now().toString();
        try {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };

            if (db) {
                await db.collection('payments').doc(paymentId).set(fullPaymentData);
            }
            paymentDatabase.set(paymentId, fullPaymentData);
            return paymentId;
        } catch (error) {
            const fullPaymentData = {
                ...paymentData,
                id: paymentId,
                status: 'pending',
                timestamp: new Date().toISOString()
            };
            paymentDatabase.set(paymentId, fullPaymentData);
            return paymentId;
        }
    }

    async getPendingPayments() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').where('status', '==', 'pending').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            }
            return Array.from(paymentDatabase.values()).filter(p => p.status === 'pending');
        } catch (error) {
            return Array.from(paymentDatabase.values()).filter(p => p.status === 'pending');
        }
    }

    async updatePayment(paymentId, updates) {
        try {
            if (db) {
                await db.collection('payments').doc(paymentId).update(updates);
            }
            const payment = paymentDatabase.get(paymentId);
            if (payment) {
                paymentDatabase.set(paymentId, { ...payment, ...updates });
            }
            return true;
        } catch (error) {
            const payment = paymentDatabase.get(paymentId);
            if (payment) {
                paymentDatabase.set(paymentId, { ...payment, ...updates });
            }
            return true;
        }
    }

    async getAllUsers() {
        try {
            if (db) {
                const usersSnapshot = await db.collection('users').get();
                return usersSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            }
            return Array.from(userDatabase.entries()).map(([id, data]) => ({ id, ...data }));
        } catch (error) {
            return Array.from(userDatabase.entries()).map(([id, data]) => ({ id, ...data }));
        }
    }

    async getSettings() {
        try {
            if (db) {
                const settingsDoc = await db.collection('settings').doc('config').get();
                if (settingsDoc.exists) {
                    return settingsDoc.data();
                }
            }
            return settingsDatabase.get('config');
        } catch (error) {
            return settingsDatabase.get('config');
        }
    }

    async updateSettings(newSettings) {
        try {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };

            if (db) {
                await db.collection('settings').doc('config').set(updatedSettings, { merge: true });
            }
            settingsDatabase.set('config', updatedSettings);
            return updatedSettings;
        } catch (error) {
            const updatedSettings = {
                ...newSettings,
                updated_at: new Date().toISOString()
            };
            settingsDatabase.set('config', updatedSettings);
            return updatedSettings;
        }
    }

    async getPayment(paymentId) {
        try {
            if (db) {
                const paymentDoc = await db.collection('payments').doc(paymentId).get();
                return paymentDoc.exists ? paymentDoc.data() : null;
            }
            return paymentDatabase.get(paymentId) || null;
        } catch (error) {
            return paymentDatabase.get(paymentId) || null;
        }
    }

    async getAllPayments() {
        try {
            if (db) {
                const paymentsSnapshot = await db.collection('payments').get();
                return paymentsSnapshot.docs.map(doc => doc.data());
            }
            return Array.from(paymentDatabase.values());
        } catch (error) {
            return Array.from(paymentDatabase.values());
        }
    }

    isMaintenanceMode() {
        return this.maintenanceMode;
    }

    async setMaintenanceMode(enabled) {
        try {
            const settings = await this.getSettings();
            settings.maintenance_mode = enabled;
            await this.updateSettings(settings);
            this.maintenanceMode = enabled;
            return true;
        } catch (error) {
            this.maintenanceMode = enabled;
            return true;
        }
    }

    async searchUsers(query) {
        try {
            const users = await this.getAllUsers();
            const lowerQuery = query.toLowerCase();
            
            return users.filter(user => 
                (user.user_id && user.user_id.toString().includes(query)) ||
                (user.username && user.username.toLowerCase().includes(lowerQuery)) ||
                (user.onexbet && user.onexbet.includes(query))
            );
        } catch (error) {
            console.error('Search users error:', error);
            return [];
        }
    }
}

// INITIALIZE SYSTEMS
const goalAI = new GoalPredictionAI();
const dbManager = new DatabaseManager();
const fakeStats = new FakeStatistics();
const imgbbUploader = new ImgBBUploader(CONFIG.IMGBB_API_KEY);

// ğŸ¯ BOT SETUP
bot.use(session({ 
    defaultSession: () => ({ 
        step: 'start',
        userData: {},
        verificationCode: null,
        accountId: null,
        paymentType: null,
        adminMode: false,
        adminStep: null,
        awaitingPaymentAccount: false,
        paymentAccount: null,
        currentBet: 0,
        originalBet: 0,
        totalProfit: 0,
        awaitingBetAmount: false,
        lastImageUrl: null,
        searchQuery: null,
        broadcastMessage: null
    })
}));

// ğŸ¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­ Ø§Ù„Ø«Ø§Ø¨ØªØ©
const getMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ'],
        ['ğŸ“¸ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©', 'ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª'],
        ['ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª', 'ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ'],
        ['ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ']
    ]).resize();
};

const getLoginKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨']
    ]).resize();
};

const getSubscriptionKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ', 'ğŸ’° Ø´Ù‡Ø±ÙŠ'],
        ['ğŸ’° 3 Ø£Ø´Ù‡Ø±', 'ğŸ’° Ø³Ù†ÙˆÙŠ'],
        ['ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©']
    ]).resize();
};

const getAdminMainKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…', 'ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª'],
        ['ğŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±', 'ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…'],
        ['ğŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª', 'ğŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†']
    ]).resize();
};

const getAdminUsersKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“‹ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†', 'âœ… Ø§Ù„Ù…Ø´ØªØ±ÙƒÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†'],
        ['ğŸ†“ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠÙ†', 'ğŸ“ˆ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminPaymentsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ“¥ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø¹Ù„Ù‚Ø©', 'âœ… Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ù‚Ø¨ÙˆÙ„Ø©'],
        ['âŒ Ø§Ù„Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¶Ø©', 'ğŸ“‹ ÙƒÙ„ Ø§Ù„Ø·Ù„Ø¨Ø§Øª'],
        ['ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

const getAdminSettingsKeyboard = () => {
    return Markup.keyboard([
        ['ğŸ’° ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±', 'ğŸ”— ØªØ¹Ø¯ÙŠÙ„ Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹'],
        ['ğŸ–¼ï¸ ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© QR', 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©'],
        ['ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†', 'ğŸ”™ Ø±Ø¬ÙˆØ¹']
    ]).resize();
};

// ğŸ› ï¸ UTILITY FUNCTIONS
function calculateRemainingDays(endDate) {
    try {
        const end = new Date(endDate);
        const now = new Date();
        const diffTime = end - now;
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
        return diffDays > 0 ? diffDays : 0;
    } catch (error) {
        return 0;
    }
}

function addSubscriptionDays(startDate, type) {
    try {
        const start = new Date(startDate);
        const types = {
            week: 7,
            month: 30,
            three_months: 90,
            year: 365
        };
        start.setDate(start.getDate() + types[type]);
        return start.toISOString();
    } catch (error) {
        const newDate = new Date();
        newDate.setDate(newDate.getDate() + 30);
        return newDate.toISOString();
    }
}

// ğŸ¯ BOT COMMANDS

bot.start(async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const userId = ctx.from.id.toString();
        const userName = ctx.from.first_name;

        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹
        try {
            await ctx.replyWithPhoto(CONFIG.START_IMAGE, {
                caption: `ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€\n\n` +
                        `ğŸ¤– *Ø£Ù‚ÙˆÙ‰ Ù†Ø¸Ø§Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ*\n` +
                        `ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}\n` +
                        `ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}`
            });
        } catch (photoError) {
            await ctx.replyWithMarkdown(`ğŸ‰ *Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}* ğŸš€`);
        }

        const existingUser = await dbManager.getUser(userId);
        
        if (existingUser) {
            ctx.session.step = 'verified';
            ctx.session.userData = existingUser;

            const remainingDays = calculateRemainingDays(existingUser.subscription_end_date);
            
            let statusMessage = '';
            if (existingUser.subscription_status === 'active' && remainingDays > 0) {
                statusMessage = `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${existingUser.subscription_type}\n` +
                               `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(existingUser.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                               `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…`;
            } else if (existingUser.free_attempts > 0) {
                statusMessage = `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${existingUser.free_attempts}`;
            } else {
                statusMessage = `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n\n` +
                               `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${existingUser.onexbet}\`\n` +
                               `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©`;
            }

            await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
            
        } else {
            ctx.session.step = 'start';
            ctx.session.userData = { userId, userName };

            const welcomeMessage = `
ğŸ” *Ù…Ø±Ø­Ø¨Ø§Ù‹ ${userName} ÙÙŠ Ù†Ø¸Ø§Ù… GOAL Predictor Pro v${CONFIG.VERSION}*

ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªÙ‚Ø¯Ù… Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø£Ù‡Ø¯Ø§Ù ÙÙŠ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª*
ğŸ¤– *Ø®ÙˆØ§Ø±Ø²Ù…ÙŠØ© Ø°ÙƒÙŠØ© Ù…Ø®ÙÙŠØ© ØªØ­Ù„Ù„ Ø§Ù„Ù…Ø¨Ø§Ø±ÙŠØ§Øª Ø¨Ø¯Ù‚Ø© Ø¹Ø§Ù„ÙŠØ©*

ğŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¯Ø®ÙˆÙ„:*
1ï¸âƒ£ Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
2ï¸âƒ£ Ø§Ø³ØªÙ„Ù… ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ (6 Ø£Ø±Ù‚Ø§Ù…)  
3ï¸âƒ£ Ø£Ø¯Ø®Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚
4ï¸âƒ£ Ø§Ø¨Ø¯Ø£ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©

ğŸ’ *Ø§Ù„Ù…Ø·ÙˆØ±:* ${CONFIG.DEVELOPER}
ğŸ“¢ *Ø§Ù„Ù‚Ù†Ø§Ø©:* ${CONFIG.CHANNEL}

ğŸ”¢ *Ø§Ù„Ø¢Ù† Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ "ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨" Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØªØ³Ø¬ÙŠÙ„*
            `;

            await ctx.replyWithMarkdown(welcomeMessage, getLoginKeyboard());
        }

    } catch (error) {
        console.error('Start command error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù„Ø§Ø­Ù‚Ø§Ù‹');
    }
});

// ğŸ“ HANDLE TEXT MESSAGES
bot.on('text', async (ctx) => {
    try {
        const settings = await dbManager.getSettings();
        if (settings.maintenance_mode && ctx.from.id.toString() !== CONFIG.ADMIN_ID) {
            await ctx.replyWithMarkdown('ğŸ”§ *Ø§Ù„Ø¨ÙˆØª ØªØ­Øª Ø§Ù„ØµÙŠØ§Ù†Ø©*\n\nâ° Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø®Ø¯Ù…Ø© Ù„ÙƒÙ…\nğŸ”„ Ø³Ù†Ø¹ÙˆØ¯ Ù‚Ø±ÙŠØ¨Ø§Ù‹ Ø¨Ø£ÙØ¶Ù„ Ù…Ù…Ø§ ÙƒØ§Ù†\n\nğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ' + CONFIG.DEVELOPER);
            return;
        }

        const text = ctx.message.text;
        const session = ctx.session;
        const userId = ctx.from.id.toString();

        // ğŸ” ADMIN COMMANDS - Ù„Ù„Ø¥Ø¯Ù…Ù† ÙÙ‚Ø·
        if (userId === CONFIG.ADMIN_ID) {
            if (text === '/admin' || text === 'ğŸ” Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…') {
                ctx.session.adminMode = true;
                ctx.session.adminStep = 'main';
                await ctx.replyWithMarkdown('ğŸ”§ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙÙŠ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…*', getAdminMainKeyboard());
                return;
            }

            if (session.adminMode) {
                await handleAdminCommands(ctx, text);
                return;
            }
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…
        if (session.adminStep === 'search_user') {
            await handleAdminSearchUser(ctx, text);
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ
        if (session.adminStep === 'broadcast') {
            await handleAdminBroadcast(ctx, text);
            return;
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†
        if (session.awaitingBetAmount) {
            const betAmount = parseFloat(text);
            if (isNaN(betAmount) || betAmount <= 0) {
                await ctx.replyWithMarkdown('âŒ *Ù…Ø¨Ù„Øº ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nğŸ’° ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…Ø¨Ù„Øº ØµØ­ÙŠØ­ Ù„Ù„Ø±Ù‡Ø§Ù†');
                return;
            }

            ctx.session.currentBet = betAmount;
            ctx.session.originalBet = betAmount;
            ctx.session.awaitingBetAmount = false;

            await ctx.replyWithMarkdown(
                `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ¯ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${betAmount}$\n\n` +
                `ğŸ“¸ *Ø§Ù„Ø¢Ù† ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„*`,
                getMainKeyboard()
            );
            return;
        }

        // ğŸ” Ø²Ø± Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        if (text === 'ğŸ” Ø¥Ø¯Ø®Ø§Ù„ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨' && session.step === 'start') {
            ctx.session.step = 'awaiting_account_id';
            await ctx.replyWithMarkdown(
                'ğŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 1:* Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ (10 Ø£Ø±Ù‚Ø§Ù…)\n\n' +
                'ğŸ’¡ *Ù…Ù„Ø§Ø­Ø¸Ø©:* ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø±Ù‚Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ'
            );
            return;
        }

        // ğŸ” STEP 1: Validate 1xBet Account
        if (session.step === 'awaiting_account_id' && /^\d{10}$/.test(text)) {
            
            ctx.session.accountId = text;
            ctx.session.step = 'awaiting_verification';
            ctx.session.verificationCode = Math.floor(100000 + Math.random() * 900000);

            await ctx.replyWithMarkdown(
                `âœ… *ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚*\n\n` +
                `ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n` +
                `ğŸ“§ *Ø§Ù„ÙƒÙˆØ¯:* \`${ctx.session.verificationCode}\`\n\n` +
                `ğŸ”¢ *Ø§Ù„Ø®Ø·ÙˆØ© 2:* Ø£Ø±Ø³Ù„ ÙƒÙˆØ¯ Ø§Ù„ØªØ­Ù‚Ù‚ Ø®Ù„Ø§Ù„ 5 Ø¯Ù‚Ø§Ø¦Ù‚`
            );

            setTimeout(() => {
                if (ctx.session.step === 'awaiting_verification') {
                    ctx.session.verificationCode = null;
                    ctx.session.step = 'start';
                }
            }, 5 * 60 * 1000);

        }
        // ğŸ” STEP 2: Verify Code
        else if (session.step === 'awaiting_verification' && /^\d{6}$/.test(text)) {
            if (parseInt(text) === ctx.session.verificationCode) {
                
                const userData = {
                    user_id: userId,
                    username: ctx.from.first_name,
                    onexbet: ctx.session.accountId,
                    free_attempts: 2,
                    subscription_status: 'free',
                    subscription_type: 'none',
                    subscription_start_date: null,
                    subscription_end_date: null,
                    joined_at: new Date().toISOString(),
                    total_predictions: 0,
                    correct_predictions: 0,
                    wins: 0,
                    losses: 0,
                    total_bets: 0,
                    total_profit: 0
                };

                await dbManager.saveUser(userId, userData);
                ctx.session.step = 'verified';
                ctx.session.userData = userData;

                await ctx.replyWithMarkdown(
                    `ğŸ‰ *ØªÙ… Ø§Ù„ØªØ­Ù‚Ù‚ Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                    `âœ… *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${ctx.session.accountId}\`\n` +
                    `ğŸ‘¤ *Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:* ${ctx.session.userData.username}\n\n` +
                    `ğŸ *ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ù…Ø­Ø§ÙˆÙ„ØªÙŠÙ† Ù…Ø¬Ø§Ù†ÙŠØªÙŠÙ†*\n\n` +
                    `ğŸ“¸ *ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ù„Ù„ØªØ­Ù„ÙŠÙ„*`,
                    getMainKeyboard()
                );

            } else {
                await ctx.replyWithMarkdown('âŒ *ÙƒÙˆØ¯ ØªØ­Ù‚Ù‚ Ø®Ø§Ø·Ø¦!*\n\nğŸ” ÙŠØ±Ø¬Ù‰ Ø¥Ø¹Ø§Ø¯Ø© Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„ØµØ­ÙŠØ­');
            }
        }
        // ğŸ’³ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹ - Ø·Ù„Ø¨ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨
        else if (session.awaitingPaymentAccount) {
            if (/^\d{10}$/.test(text)) {
                const userData = await dbManager.getUser(userId);
                userData.onexbet = text;
                await dbManager.saveUser(userId, userData);
                
                ctx.session.awaitingPaymentAccount = false;
                ctx.session.paymentAccount = text;
                
                await ctx.replyWithMarkdown(
                    `âœ… *ØªÙ… Ø­ÙØ¸ Ø±Ù‚Ù… Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${text}\`\n\n` +
                    `ğŸ“¸ *Ø§Ù„Ø¢Ù† ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹*`
                );
            } else {
                await ctx.replyWithMarkdown('âŒ *Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nğŸ”¢ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ù…ÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù…');
            }
            return;
        }
        // ğŸ¯ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ø«Ø§Ø¨ØªØ© Ø¨Ø¹Ø¯ Ø§Ù„ØªØ­Ù‚Ù‚
        else if (session.step === 'verified') {
            const userData = await dbManager.getUser(userId);
            
            if (!userData) {
                await ctx.replyWithMarkdown('âŒ *Ø¬Ù„Ø³Ø© Ù…Ù†ØªÙ‡ÙŠØ©*\n\nğŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
                return;
            }

            switch (text) {
                case 'ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ':
                    if (session.lastImageUrl) {
                        await handleNextPrediction(ctx, userData);
                    } else {
                        ctx.session.awaitingBetAmount = true;
                        await ctx.replyWithMarkdown(
                            'ğŸ’° *Ø£Ø¯Ø®Ù„ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:*\n\n' +
                            'ğŸ’µ ÙŠØ±Ø¬Ù‰ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ù…Ø¨Ù„Øº Ø§Ù„Ø°ÙŠ ØªØ±ÙŠØ¯ Ø§Ù„Ø±Ù‡Ø§Ù† Ø¹Ù„ÙŠÙ‡ (Ø¨Ø§Ù„Ø¯ÙˆÙ„Ø§Ø±)\n' +
                            'ğŸ“ Ù…Ø«Ø§Ù„: 10 Ø£Ùˆ 25.5'
                        );
                    }
                    break;

                case 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ':
                    await handleUserStats(ctx, userData);
                    break;

                case 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª':
                    await handleBotStats(ctx);
                    break;

                case 'ğŸ“¸ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©':
                    await ctx.replyWithMarkdown(
                        'ğŸ“¸ *ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø§Ù„Ø¢Ù†*\n\n' +
                        'ğŸ¯ *Ø¨Ø¹Ø¯ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø³ØªØ­ØµÙ„ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ÙÙˆØ±ÙŠ*',
                        getMainKeyboard()
                    );
                    break;

                case 'ğŸ’³ Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª':
                    await handleSubscriptions(ctx, userData);
                    break;

                case 'ğŸ‘¤ Ø­Ø§Ù„Ø© Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ':
                    await handleSubscriptionStatus(ctx, userData);
                    break;

                case 'ğŸ†˜ Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ':
                    await ctx.replyWithMarkdown(
                        `ğŸ†˜ *Ø§Ù„Ø¯Ø¹Ù… Ø§Ù„ÙÙ†ÙŠ*\n\n` +
                        `ğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¯Ø¹Ù…:\n` +
                        `ğŸ‘¤ ${CONFIG.DEVELOPER}\n` +
                        `ğŸ“¢ ${CONFIG.CHANNEL}\n\n` +
                        `â° Ù…ØªØ§Ø­ÙˆÙ† 24/7 Ù„Ø®Ø¯Ù…ØªÙƒÙ…`,
                        getMainKeyboard()
                    );
                    break;

                case 'ğŸ”™ Ø§Ù„Ø±Ø¬ÙˆØ¹ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©':
                    await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    break;

                default:
                    if (text.startsWith('ğŸ’° ')) {
                        await handleSubscriptionSelection(ctx, userData, text);
                    } else {
                        await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
                    }
                    break;
            }
        }
        // ğŸ” Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…Ø³Ø¬Ù„ ÙˆØ­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø±
        else if (['ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ', 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙŠ', 'ğŸ“¸ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø©', 'ğŸ‘¥ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª'].includes(text)) {
            await ctx.replyWithMarkdown(
                'âŒ *ÙŠØ¬Ø¨ Ø§Ù„ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„Ø§Ù‹*\n\n' +
                'ğŸ” Ø£Ø±Ø³Ù„ /start Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„',
                getLoginKeyboard()
            );
        } else {
            await ctx.replyWithMarkdown('ğŸ”™ *Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©*', getMainKeyboard());
        }

    } catch (error) {
        console.error('Text handler error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹', getMainKeyboard());
    }
});

// ğŸ–¼ï¸ IMAGE ANALYSIS HANDLER - Ù…Ø¹Ø¯Ù„ Ù„Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙˆØ± Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© ÙÙ‚Ø·
bot.on('photo', async (ctx) => {
    try {
        const userId = ctx.from.id.toString();
        const session = ctx.session;

        // ==== Ø¯Ø¹Ù… Ø±ÙØ¹ ØµÙˆØ±Ø© Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù† Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø³Ø¹Ø§Ø± (OCR) ====
        if (ctx.from && ctx.from.id && ctx.from.id.toString() === CONFIG.ADMIN_ID && ctx.session && ctx.session.adminStep === 'price_edit') {
            try {
                const photoForAdmin = ctx.message.photo[ctx.message.photo.length - 1];
                const fileLinkAdmin = await bot.telegram.getFileLink(photoForAdmin.file_id);
                const imageUrlAdmin = fileLinkAdmin.href;
                const visionResultAdmin = await callVisionAPI(imageUrlAdmin);
                const respAdmin = visionResultAdmin && visionResultAdmin.responses && visionResultAdmin.responses[0];
                const fullTextAdmin = respAdmin && respAdmin.textAnnotations ? respAdmin.textAnnotations.map(t=>t.description).join(' ').toLowerCase() : '';

                const extractNumber = (keyword) => {
                    const idx = fullTextAdmin.indexOf(keyword);
                    if (idx === -1) return null;
                    const sub = fullTextAdmin.slice(idx, idx+200);
                    const m = sub.match(/(\d+(\.\d+)?)/);
                    return m ? parseFloat(m[1]) : null;
                };

                const maybeWeek = extractNumber('Ø£Ø³Ø¨ÙˆØ¹') || extractNumber('week') || extractNumber('week:');
                const maybeMonth = extractNumber('Ø´Ù‡Ø±ÙŠ') || extractNumber('month') || extractNumber('month:');
                const maybe3 = extractNumber('3 Ø£Ø´Ù‡Ø±') || extractNumber('3') || extractNumber('three_months');
                const maybeYear = extractNumber('Ø³Ù†Ùˆ') || extractNumber('year') || extractNumber('Ø³Ù†Ø©');

                const settings = await dbManager.getSettings();
                settings.prices = settings.prices || {};

                if (maybeWeek) settings.prices.week = maybeWeek;
                if (maybeMonth) settings.prices.month = maybeMonth;
                if (maybe3) settings.prices.three_months = maybe3;
                if (maybeYear) settings.prices.year = maybeYear;

                await dbManager.updateSettings(settings);
                await ctx.replyWithMarkdown('âœ… ØªÙ… Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ ÙˆØ­ÙØ¸ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ø§Ù„ØµÙˆØ±Ø©. ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©.', getAdminSettingsKeyboard());
                ctx.session.adminStep = 'settings';
                return;
            } catch (err) {
                console.error('Admin price image OCR error:', err);
                await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± Ù…Ù† Ø§Ù„ØµÙˆØ±Ø©', getAdminSettingsKeyboard());
                ctx.session.adminStep = 'settings';
                return;
            }
        }

        
        // ğŸ’³ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ± Ø§Ù„Ø¯ÙØ¹
        if (session.paymentType) {
            await handlePaymentScreenshot(ctx, userId);
            return;
        }

        const userData = await dbManager.getUser(userId);
        if (!userData || !userData.onexbet) {
            await ctx.replyWithMarkdown('âŒ *ÙŠØ¬Ø¨ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø­Ø³Ø§Ø¨ Ø£ÙˆÙ„Ø§Ù‹*\n\nğŸ” Ø£Ø±Ø³Ù„ /start Ù„Ù„Ø¨Ø¯Ø¡', getLoginKeyboard());
            return;
        }

        // ğŸ” Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© Ø£Ùˆ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ
        if (userData.subscription_status !== 'active' && userData.free_attempts <= 0) {
            await ctx.replyWithMarkdown(
                'ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ©*\n\n' +
                'ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©',
                getMainKeyboard()
            );
            return;
        }

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙˆØ¬ÙˆØ¯ Ù…Ø¨Ù„Øº Ø±Ù‡Ø§Ù†
        if (!session.currentBet || session.currentBet <= 0) {
            await ctx.replyWithMarkdown(
                'âŒ *ÙŠØ¬Ø¨ ØªØ­Ø¯ÙŠØ¯ Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù† Ø£ÙˆÙ„Ø§Ù‹*\n\n' +
                'ğŸ’° Ø§Ø³ØªØ®Ø¯Ù… Ø²Ø± "ğŸ¯ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ" Ù„ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…Ø¨Ù„Øº',
                getMainKeyboard()
            );
            return;
        }

        // ğŸ“¸ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ±Ø©
        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        // Ø­ÙØ¸ Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ø¬Ù„Ø³Ø© Ù„Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù… Ù„Ø§Ø­Ù‚Ø§Ù‹
        ctx.session.lastImageUrl = imageUrl;

        const processingMsg = await ctx.reply('ğŸ”„ Ø¬Ø§Ø±ÙŠ ØªØ­Ù„ÙŠÙ„ ØµÙˆØ±Ø© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...');

        try {
            const prediction = await goalAI.analyzeImageWithAI(imageUrl);

            // Ø¥Ø°Ø§ Ø±ÙØ¶ Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø§Ø³ØªØ±Ø¬Ø¹ Ø§Ù„ØµÙˆØ±Ø© Ù…Ø¹ Ø±Ø³Ø§Ù„Ø©
            if (prediction && prediction.accepted === false) {
                try { await ctx.deleteMessage(processingMsg.message_id); } catch(e){}
                await ctx.replyWithPhoto(imageUrl, {
                    caption: `âŒ *Ù„Ø§ ÙŠØªÙ… Ù‚Ø¨ÙˆÙ„ Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ø© Ù„Ø£Ù† Ø§Ù„Ø´Ø±ÙˆØ· ØºÙŠØ± ÙƒØ§Ù…Ù„Ø©.*\n\n` +
                             `Ø§Ù„Ø³Ø¨Ø¨: ${prediction.reason || 'Ø´Ø±ÙˆØ· Ù„Ø§ ØªØªØ­Ù‚Ù‚'}\n\n` +
                             `ğŸ” *Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ù„ÙƒØ´Ù (Ù…Ù‚ØªØ·Ù):* \n` +
                             `â€¢ Ù…ÙŠØ³ÙŠ: ${prediction.detected.hasMessi ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}\n` +
                             `â€¢ Ù†ÙŠÙ…Ø§Ø±: ${prediction.detected.hasNeymar ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}\n` +
                             `â€¢ Ø±ÙˆÙ†Ø§Ù„Ø¯Ùˆ: ${prediction.detected.hasRonaldo ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}\n` +
                             `â€¢ 'Ù‡Ø¯Ù' Ù…ÙˆØ¬ÙˆØ¯: ${prediction.detected.hasGoal ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}\n` +
                             `â€¢ 'Ù„Ø§ Ù‡Ø¯Ù' Ù…ÙˆØ¬ÙˆØ¯: ${prediction.detected.hasNoGoal ? 'Ù†Ø¹Ù…' : 'Ù„Ø§'}\n\n` +
                             `Ù‡Ø°Ù‡ Ø§Ù„ØµÙˆØ±Ù‡ ÙÙŠ Ø§Ù„Ø§Ø¹Ù„Ù‰ â˜ï¸`,
                    parse_mode: 'Markdown'
                });
                return;
            }

            // ğŸ“Š ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            if (userData.subscription_status !== 'active') {
                userData.free_attempts--;
            }
            userData.total_predictions = (userData.total_predictions || 0) + 1;
            userData.total_bets = (userData.total_bets || 0) + session.currentBet;
            userData.lastPrediction = prediction;
            await dbManager.saveUser(userId, userData);

            const analysisMessage = `
ğŸ¤– *ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… - v${CONFIG.VERSION}*

ğŸ“¸ *Ø§Ù„ØµÙˆØ±Ø©:* âœ… ØªÙ… Ø§Ù„ØªØ­Ù„ÙŠÙ„ Ø¨Ù†Ø¬Ø§Ø­
ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${session.currentBet}$

ğŸ¯ *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ¯ *Ø§Ù„Ø«Ù‚Ø©:* ${prediction.confidence}%

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}

${userData.subscription_status !== 'active' ? 
    `ğŸ†“ *Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠØ©:* ${userData.free_attempts}` : 
    `âœ… *Ø§Ø´ØªØ±Ø§Ùƒ Ù†Ø´Ø· - Ù…Ø­Ø§ÙˆÙ„Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©*`}
            `;

            await ctx.replyWithMarkdown(analysisMessage);
            
            // Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©
            const resultKeyboard = Markup.inlineKeyboard([
                [
                    Markup.button.callback(`ğŸŠ Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ - Ø±Ø¨Ø­ ${session.currentBet * 2}$`, `win_${Date.now()}`),
                    Markup.button.callback(`ğŸ”„ Ø®Ø³Ø±Øª - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ`, `lose_${Date.now()}`)
                ]
            ]);

            await ctx.replyWithMarkdown(
                'ğŸ“Š *Ù…Ø§ Ù‡ÙŠ Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ØŸ*\n\n' +
                `ğŸŠ *Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹* - ØªØ±Ø¨Ø­ ${session.currentBet * 2}$\n` +
                `ğŸ”„ *Ø®Ø³Ø±Øª* - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ø±Ù‡Ø§Ù†\n\n` +
                'âœ¨ Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠÙƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹',
                resultKeyboard
            );

            await ctx.deleteMessage(processingMsg.message_id);

        } catch (analysisError) {
            console.error('Analysis error:', analysisError);
            
            const fallbackPrediction = goalAI.generateSmartPrediction(userId);
            
            await ctx.replyWithMarkdown(
                `ğŸ¤– *Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠ - ØªØ­Ù„ÙŠÙ„ ÙÙˆØ±ÙŠ*\n\n` +
                `ğŸ¯ ${fallbackPrediction.type}\n` +
                `ğŸ“ˆ ${fallbackPrediction.probability}% | ğŸ¯ ${fallbackPrediction.confidence}%\n\n` +
                `ğŸ’¡ ${fallbackPrediction.reasoning}`,
                getMainKeyboard()
            );

            await ctx.deleteMessage(processingMsg.message_id);
        }

    } catch (error) {
        console.error('Photo handler error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ­Ù„ÙŠÙ„*', getMainKeyboard());
    }
});

// ğŸ¯ HANDLE CALLBACK QUERIES - Ù…Ø¹Ø¯Ù„ Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ø®Ø³Ø§Ø±Ø©
bot.on('callback_query', async (ctx) => {
    try {
        const callbackData = ctx.callbackQuery.data;
        const userId = ctx.from.id.toString();
        
        if (callbackData.startsWith('win_') || callbackData.startsWith('lose_')) {
            const isWin = callbackData.startsWith('win_');
            
            const userData = await dbManager.getUser(userId);
            if (!userData) {
                await ctx.answerCbQuery('âŒ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…');
                return;
            }
            
            if (isWin) {
                const profit = ctx.session.currentBet;
                userData.wins = (userData.wins || 0) + 1;
                userData.correct_predictions = (userData.correct_predictions || 0) + 1;
                userData.total_profit = (userData.total_profit || 0) + profit;
                ctx.session.totalProfit += profit;
                
                await ctx.answerCbQuery(`ğŸŠ Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ ÙˆØ±Ø¨Ø­Øª ${profit}$`);
                
                await ctx.replyWithMarkdown(
                    `ğŸŠ *Ù…Ø¨Ø±ÙˆÙƒ! Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø¨Ù†Ø¬Ø§Ø­* âœ¨\n\n` +
                    `âœ… ØªÙˆÙ‚Ø¹Ùƒ ÙƒØ§Ù† Ø¯Ù‚ÙŠÙ‚Ø§Ù‹ ÙˆÙ…Ù…ÙŠØ²Ø§Ù‹\n` +
                    `ğŸ’° Ø±Ø¨Ø­Øª: ${profit}$\n` +
                    `ğŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø£Ø±Ø¨Ø§Ø­Ùƒ: ${ctx.session.totalProfit}$\n\n` +
                    `ğŸ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø¯Ø¡ Ø¨ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯`,
                    getMainKeyboard()
                );
                
            } else {
                // Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ø±Ù‡Ø§Ù† ÙˆØªÙˆÙ„ÙŠØ¯ ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                const newBet = ctx.session.currentBet * 2;
                userData.losses = (userData.losses || 0) + 1;
                ctx.session.currentBet = newBet;
                
                await ctx.answerCbQuery(`ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ...`);
                
                // ØªÙˆÙ„ÙŠØ¯ ØªÙˆÙ‚Ø¹ Ø¬Ø¯ÙŠØ¯ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
                const newPrediction = goalAI.generateNextPrediction(userId);
                
                await ctx.replyWithMarkdown(
                    `ğŸ”„ *Ø®Ø³Ø±Øª Ù‡Ø°Ù‡ Ø§Ù„Ø¬ÙˆÙ„Ø©*\n\n` +
                    `ğŸ“ˆ Ø§Ù„Ø±Ù‡Ø§Ù† Ø§Ù„ØªØ§Ù„ÙŠ Ù…Ø¶Ø§Ø¹Ù: ${newBet}$\n` +
                    `ğŸ’ª Ù„Ø§ ØªÙˆÙ‚Ù.. Ø§Ø³ØªÙ…Ø± ÙÙŠ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©\n\n` +
                    `ğŸ¯ *Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ:*\n` +
                    `${newPrediction.type}\n` +
                    `ğŸ“ˆ ${newPrediction.probability}% | ğŸ¯ ${newPrediction.confidence}%\n` +
                    `ğŸ’¡ ${newPrediction.reasoning}`,
                    getMainKeyboard()
                );
                
                // Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù„Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯
                const resultKeyboard = Markup.inlineKeyboard([
                    [
                        Markup.button.callback(`ğŸŠ Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ - Ø±Ø¨Ø­ ${newBet * 2}$`, `win_${Date.now()}`),
                        Markup.button.callback(`ğŸ”„ Ø®Ø³Ø±Øª - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ`, `lose_${Date.now()}`)
                    ]
                ]);

                await ctx.replyWithMarkdown(
                    'ğŸ“Š *Ù…Ø§ Ù‡ÙŠ Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ØŸ*',
                    resultKeyboard
                );
            }
            
            await dbManager.saveUser(userId, userData);
            
            try {
                await ctx.deleteMessage(ctx.callbackQuery.message.message_id);
            } catch (deleteError) {
                console.log('Could not delete message:', deleteError);
            }
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù‚Ø¨ÙˆÙ„ ÙˆØ§Ù„Ø±ÙØ¶ ÙÙŠ Ø§Ù„Ø¥Ø¯Ù…Ù†
        else if (callbackData.startsWith('accept_')) {
            const paymentId = callbackData.split('_')[1];
            await handlePaymentAccept(ctx, paymentId);
        }
        else if (callbackData.startsWith('reject_')) {
            const paymentId = callbackData.split('_')[1];
            await handlePaymentReject(ctx, paymentId);
        }
        
    } catch (error) {
        console.error('Callback query error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø©');
    }
});

// ğŸ¯ HANDLER FUNCTIONS

// Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ
async function handleNextPrediction(ctx, userData) {
    try {
        if (!ctx.session.lastImageUrl) {
            await ctx.replyWithMarkdown('âŒ *Ù„Ø§ ØªÙˆØ¬Ø¯ ØµÙˆØ±Ø© Ø³Ø§Ø¨Ù‚Ø©*\n\nğŸ“¸ ÙŠØ±Ø¬Ù‰ Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ø£ÙˆÙ„Ø§Ù‹');
            return;
        }

        const processingMsg = await ctx.reply('ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ...');
        
        const prediction = await goalAI.analyzeImageWithAI(ctx.session.lastImageUrl);
        
        userData.total_predictions = (userData.total_predictions || 0) + 1;
        userData.total_bets = (userData.total_bets || 0) + ctx.session.currentBet;
        userData.lastPrediction = prediction;
        await dbManager.saveUser(ctx.from.id.toString(), userData);

        const analysisMessage = `
ğŸ¤– *ØªØ­Ù„ÙŠÙ„ Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„Ø§ØµØ·Ù†Ø§Ø¹ÙŠ Ø§Ù„Ù…ØªÙ‚Ø¯Ù… - v${CONFIG.VERSION}*

ğŸ“¸ *Ø§Ù„ØµÙˆØ±Ø©:* âœ… Ø¥Ø¹Ø§Ø¯Ø© Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
ğŸ•’ *Ø§Ù„ÙˆÙ‚Øª:* ${new Date().toLocaleString('ar-EG')}
ğŸ” *Ø§Ù„Ø­Ø³Ø§Ø¨:* \`${userData.onexbet}\`
ğŸ’° *Ù…Ø¨Ù„Øº Ø§Ù„Ø±Ù‡Ø§Ù†:* ${ctx.session.currentBet}$

ğŸ¯ *Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.type}
ğŸ“ˆ *Ø§Ù„Ø§Ø­ØªÙ…Ø§Ù„ÙŠØ©:* ${prediction.probability}%
ğŸ¯ *Ø§Ù„Ø«Ù‚Ø©:* ${prediction.confidence}%

ğŸ’¡ *Ø§Ù„ØªØ­Ù„ÙŠÙ„:*
${prediction.reasoning}
        `;

        await ctx.replyWithMarkdown(analysisMessage);
        
        // Ø¥Ø¶Ø§ÙØ© Ø£Ø²Ø±Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©
        const resultKeyboard = Markup.inlineKeyboard([
            [
                Markup.button.callback(`ğŸŠ Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹ - Ø±Ø¨Ø­ ${ctx.session.currentBet * 2}$`, `win_${Date.now()}`),
                Markup.button.callback(`ğŸ”„ Ø®Ø³Ø±Øª - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ`, `lose_${Date.now()}`)
            ]
        ]);

        await ctx.replyWithMarkdown(
            'ğŸ“Š *Ù…Ø§ Ù‡ÙŠ Ù†ØªÙŠØ¬Ø© Ø§Ù„ØªÙˆÙ‚Ø¹ØŸ*\n\n' +
            `ğŸŠ *Ù†Ø¬Ø­ Ø§Ù„ØªÙˆÙ‚Ø¹* - ØªØ±Ø¨Ø­ ${ctx.session.currentBet * 2}$\n` +
            `ğŸ”„ *Ø®Ø³Ø±Øª* - Ø¬Ø±Ø¨ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ Ø¨Ù…Ø¶Ø§Ø¹ÙØ© Ø§Ù„Ø±Ù‡Ø§Ù†\n\n` +
            'âœ¨ Ø³ÙŠØªÙ… ØªØ­Ø¯ÙŠØ« Ø¥Ø­ØµØ§Ø¦ÙŠÙƒ ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹',
            resultKeyboard
        );

        await ctx.deleteMessage(processingMsg.message_id);

    } catch (error) {
        console.error('Next prediction error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø§Ù„ØªØ§Ù„ÙŠ*', getMainKeyboard());
    }
}

async function handleUserStats(ctx, userData) {
    const accuracy = userData.correct_predictions > 0 ? 
        Math.round((userData.correct_predictions / (userData.total_predictions || 1)) * 100) : 0;
    
    let subscriptionInfo = '';
    if (userData.subscription_status === 'active') {
        const remainingDays = calculateRemainingDays(userData.subscription_end_date);
        subscriptionInfo = `\nğŸ“¦ *Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ:* ${userData.subscription_type}\n` +
                          `â³ *Ù…ØªØ¨Ù‚ÙŠ:* ${remainingDays} ÙŠÙˆÙ…`;
    } else {
        subscriptionInfo = `\nğŸ†“ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©:* ${userData.free_attempts}`;
    }
    
    await ctx.replyWithMarkdown(
        `ğŸ“Š *Ø¥Ø­ØµØ§Ø¦ÙŠØ§ØªÙƒ Ø§Ù„Ø´Ø®ØµÙŠØ©*\n\n` +
        `ğŸ” ${userData.onexbet}\n` +
        `ğŸ‘¤ ${userData.username}\n` +
        `ğŸ“ˆ ${userData.total_predictions || 0} ØªÙˆÙ‚Ø¹\n` +
        `âœ… ${userData.correct_predictions || 0} ØµØ­ÙŠØ­Ø©\n` +
        `ğŸ¯ ${accuracy}% Ø¯Ù‚Ø©\n` +
        `ğŸ‰ ${userData.wins || 0} ÙÙˆØ²\n` +
        `ğŸ’” ${userData.losses || 0} Ø®Ø³Ø§Ø±Ø©\n` +
        `ğŸ’° Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø±Ù‡Ø§Ù†Ø§Øª: ${userData.total_bets || 0}$\n` +
        `ğŸ’µ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø£Ø±Ø¨Ø§Ø­: ${userData.total_profit || 0}$` +
        subscriptionInfo,
        getMainKeyboard()
    );
}

async function handleBotStats(ctx) {
    const stats = fakeStats.getStats();
    await ctx.replyWithMarkdown(
        `ğŸ‘¥ *Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª*\n\n` +
        `ğŸ‘¤ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†: ${stats.totalUsers.toLocaleString()}\n` +
        `ğŸŸ¢ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ù†Ø´Ø·ÙŠÙ† Ø§Ù„Ø¢Ù†: ${stats.activeUsers}\n` +
        `ğŸ“Š Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª Ø§Ù„ÙŠÙˆÙ…ÙŠØ©: ${Math.floor(stats.activeUsers * 8.5)}\n\n` +
        `ğŸ¯ *Ø§Ù„Ù†Ø¸Ø§Ù… ÙŠØ¹Ù…Ù„ Ø¨ÙƒÙØ§Ø¡Ø© Ø¹Ø§Ù„ÙŠØ©*`,
        getMainKeyboard()
    );
}

async function handleSubscriptions(ctx, userData) {
    try {
        const settings = await dbManager.getSettings();
        const prices = settings.prices;
        const payment_links = settings.payment_links;
        
        const subscriptionMessage = `
ğŸ’³ *Ø¨Ø§Ù‚Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø§Ù„Ù…ØªØ§Ø­Ø©*

ğŸ’° *Ø£Ø³Ø¨ÙˆØ¹ÙŠ:* ${prices.week}$
â° Ù…Ø¯Ø©: 7 Ø£ÙŠØ§Ù…

ğŸ’° *Ø´Ù‡Ø±ÙŠ:* ${prices.month}$  
â° Ù…Ø¯Ø©: 30 ÙŠÙˆÙ…Ø§Ù‹

ğŸ’° *3 Ø£Ø´Ù‡Ø±:* ${prices.three_months}$
â° Ù…Ø¯Ø©: 90 ÙŠÙˆÙ…Ø§Ù‹

ğŸ’° *Ø³Ù†ÙˆÙŠ:* ${prices.year}$
â° Ù…Ø¯Ø©: 365 ÙŠÙˆÙ…Ø§Ù‹

ğŸ“‹ *Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø¯ÙØ¹:*
1. Ø§Ø®ØªØ± Ø§Ù„Ø¨Ø§Ù‚Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
2. Ø§Ø¯ÙØ¹ Ø¹Ø¨Ø± Ø§Ù„Ø±Ø§Ø¨Ø·
3. Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)
4. Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹
5. Ø§Ù†ØªØ¸Ø± Ø§Ù„ØªÙØ¹ÙŠÙ„ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©
        `;

        await ctx.replyWithMarkdown(subscriptionMessage, getSubscriptionKeyboard());
    } catch (error) {
        console.error('Subscriptions error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø§Ø´ØªØ±Ø§ÙƒØ§Øª*', getMainKeyboard());
    }
}

async function handleSubscriptionSelection(ctx, userData, text) {
    const subscriptionTypeMap = {
        'ğŸ’° Ø£Ø³Ø¨ÙˆØ¹ÙŠ': 'week',
        'ğŸ’° Ø´Ù‡Ø±ÙŠ': 'month', 
        'ğŸ’° 3 Ø£Ø´Ù‡Ø±': 'three_months',
        'ğŸ’° Ø³Ù†ÙˆÙŠ': 'year'
    };

    const subscriptionType = subscriptionTypeMap[text];
    if (!subscriptionType) {
        await ctx.replyWithMarkdown('âŒ *Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± ØµØ­ÙŠØ­*', getSubscriptionKeyboard());
        return;
    }

    try {
        const settings = await dbManager.getSettings();
        const prices = settings.prices;
        const payment_links = settings.payment_links;

        ctx.session.paymentType = subscriptionType;
        ctx.session.awaitingPaymentAccount = true;

        await ctx.replyWithMarkdown(
            `ğŸ’³ *Ø¨Ø§Ù‚Ø© ${text.replace('ğŸ’° ', '')}*\n\n` +
            `ğŸ’° Ø§Ù„Ø³Ø¹Ø±: ${prices[subscriptionType]}$\n` +
            `ğŸ”— Ø±Ø§Ø¨Ø· Ø§Ù„Ø¯ÙØ¹: ${payment_links[subscriptionType]}\n\n` +
            `ğŸ“‹ *Ø®Ø·ÙˆØ§Øª Ø§Ù„Ø¥ÙƒÙ…Ø§Ù„:*\n` +
            `1. Ø§Ø¯ÙØ¹ Ø¹Ø¨Ø± Ø§Ù„Ø±Ø§Ø¨Ø· Ø£Ø¹Ù„Ø§Ù‡\n` +
            `2. Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet (10 Ø£Ø±Ù‚Ø§Ù…)\n` +
            `3. Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹\n\n` +
            `ğŸ”¢ *Ø§Ù„Ø¢Ù† Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet Ø§Ù„Ù…ÙƒÙˆÙ† Ù…Ù† 10 Ø£Ø±Ù‚Ø§Ù…:*`
        );
    } catch (error) {
        console.error('Subscription selection error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø·Ù„Ø¨ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ*', getSubscriptionKeyboard());
    }
}

async function handleSubscriptionStatus(ctx, userData) {
    let statusMessage = '';
    
    if (userData.subscription_status === 'active') {
        const remainingDays = calculateRemainingDays(userData.subscription_end_date);
        statusMessage = `âœ… *Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ù†Ø´Ø·*\n\n` +
                       `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ğŸ“¦ Ø§Ù„Ù†ÙˆØ¹: ${userData.subscription_type}\n` +
                       `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(userData.subscription_end_date).toLocaleDateString('ar-EG')}\n` +
                       `â³ Ù…ØªØ¨Ù‚ÙŠ: ${remainingDays} ÙŠÙˆÙ…`;
    } else if (userData.free_attempts > 0) {
        statusMessage = `ğŸ¯ *Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ§Ø­Ø©*\n\n` +
                       `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ğŸ†“ Ù…Ø­Ø§ÙˆÙ„Ø§Øª Ù…Ø¬Ø§Ù†ÙŠØ©: ${userData.free_attempts}\n\n` +
                       `ğŸ’³ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙŠØ²Ø§Øª ØºÙŠØ± Ù…Ø­Ø¯ÙˆØ¯Ø©`;
    } else {
        statusMessage = `ğŸš« *Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª*\n\n` +
                       `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: \`${userData.onexbet}\`\n` +
                       `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø©`;
    }
    
    await ctx.replyWithMarkdown(statusMessage, getMainKeyboard());
}

async function handlePaymentScreenshot(ctx, userId) {
    try {
        const userData = await dbManager.getUser(userId);
        const photo = ctx.message.photo[ctx.message.photo.length - 1];
        const fileLink = await bot.telegram.getFileLink(photo.file_id);
        const imageUrl = fileLink.href;

        const settings = await dbManager.getSettings();
        const prices = settings.prices;

        const accountNumber = ctx.session.paymentAccount || userData.onexbet;

        const uploadResult = await imgbbUploader.uploadImage(imageUrl);
        
        const paymentData = {
            user_id: userId,
            onexbet: accountNumber,
            screenshot_url: uploadResult.url,
            amount: prices[ctx.session.paymentType],
            subscription_type: ctx.session.paymentType,
            username: userData.username,
            timestamp: new Date().toISOString()
        };

        const paymentId = await dbManager.addPayment(paymentData);
        
        // Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ù„Ø¥Ø¯Ø§Ø±Ø©
        try {
            await bot.telegram.sendMessage(
                CONFIG.ADMIN_ID,
                `ğŸ†• *Ø·Ù„Ø¨ Ø¯ÙØ¹ Ø¬Ø¯ÙŠØ¯*\n\n` +
                `ğŸ‘¤ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…: ${userData.username}\n` +
                `ğŸ” Ø§Ù„Ø­Ø³Ø§Ø¨: ${accountNumber}\n` +
                `ğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${paymentData.amount}$\n` +
                `ğŸ“¦ Ø§Ù„Ø¨Ø§Ù‚Ø©: ${ctx.session.paymentType}\n` +
                `ğŸ†” Ø§Ù„Ø±Ù‚Ù…: ${paymentId}\n` +
                `ğŸ“… Ø§Ù„ÙˆÙ‚Øª: ${new Date().toLocaleString('ar-EG')}\n` +
                `ğŸ”— ØµÙˆØ±Ø©: ${uploadResult.url}`,
                {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [
                                { text: 'âœ… Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ', callback_data: `accept_${paymentId}` },
                                { text: 'âŒ Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨', callback_data: `reject_${paymentId}` }
                            ]
                        ]
                    }
                }
            );
        } catch (error) {
            console.error('Error notifying admin:', error);
        }

        await ctx.replyWithMarkdown(
            'ğŸ“© *ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­*\n\n' +
            `âœ… Ø§Ù„Ø­Ø³Ø§Ø¨: \`${accountNumber}\`\n` +
            `âœ… Ø§Ù„Ø¨Ø§Ù‚Ø©: ${ctx.session.paymentType}\n` +
            `ğŸ’° Ø§Ù„Ù…Ø¨Ù„Øº: ${paymentData.amount}$\n\n` +
            'âœ… Ø³ÙŠØªÙ… Ù…Ø±Ø§Ø¬Ø¹ØªÙ‡Ø§ Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ÙÙŠ Ø£Ù‚Ø±Ø¨ ÙˆÙ‚Øª\n' +
            'â° Ø¹Ø§Ø¯Ø©Ù‹ Ø®Ù„Ø§Ù„ 24 Ø³Ø§Ø¹Ø©\n\n' +
            `ğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ${CONFIG.DEVELOPER}`,
            getMainKeyboard()
        );

        ctx.session.paymentType = null;
        ctx.session.awaitingPaymentAccount = false;
        ctx.session.paymentAccount = null;
    } catch (error) {
        console.error('Payment screenshot error:', error);
        await ctx.replyWithMarkdown('âŒ *Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹*', getMainKeyboard());
    }
}

// ğŸ”§ ADMIN HANDLERS - Ù…Ø¹Ø¯Ù„ Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
async function handleAdminCommands(ctx, text) {
    const session = ctx.session;
    
    try {
        // Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
        if (session.adminStep === 'price_edit') {
            await handleAdminPriceEdit(ctx, text);
            return;
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
        if (session.adminStep === 'link_edit') {
            await handleAdminLinkEdit(ctx, text);
            return;
        }
        
        // Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© QR
        if (session.adminStep === 'qr_edit') {
            await handleAdminQREdit(ctx, text);
            return;
        }

        switch (session.adminStep) {
            case 'main':
                await handleAdminMain(ctx, text);
                break;
            case 'users':
                await handleAdminUsers(ctx, text);
                break;
            case 'payments':
                await handleAdminPayments(ctx, text);
                break;
            case 'settings':
                await handleAdminSettings(ctx, text);
                break;
            default:
                await handleAdminMain(ctx, text);
                break;
        }
    } catch (error) {
        console.error('Admin commands error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ù…Ø±', getAdminMainKeyboard());
    }
}

async function handleAdminMain(ctx, text) {
    try {
        switch (text) {
            case 'ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…':
                await handleAdminStats(ctx);
                break;
                
            case 'ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†':
                ctx.session.adminStep = 'users';
                await ctx.replyWithMarkdown('ğŸ‘¥ *Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*', getAdminUsersKeyboard());
                break;
                
            case 'ğŸ’° Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹':
                ctx.session.adminStep = 'payments';
                await ctx.replyWithMarkdown('ğŸ’° *Ø¥Ø¯Ø§Ø±Ø© Ø·Ù„Ø¨Ø§Øª Ø§Ù„Ø¯ÙØ¹*', getAdminPaymentsKeyboard());
                break;
                
            case 'âš™ï¸ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª':
                ctx.session.adminStep = 'settings';
                await ctx.replyWithMarkdown('âš™ï¸ *Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©*', getAdminSettingsKeyboard());
                break;

            case 'ğŸ“¢ Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±':
                ctx.session.adminStep = 'broadcast';
                await ctx.replyWithMarkdown(
                    'ğŸ“¢ *Ø¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø± Ø¬Ù…Ø§Ø¹ÙŠ*\n\n' +
                    'âœï¸ Ø§Ù„Ø±Ø¬Ø§Ø¡ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„ØªÙŠ ØªØ±ÙŠØ¯ Ø¥Ø±Ø³Ø§Ù„Ù‡Ø§ Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†:'
                );
                break;

            case 'ğŸ” Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…':
                ctx.session.adminStep = 'search_user';
                await ctx.replyWithMarkdown(
                    'ğŸ” *Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…*\n\n' +
                    'ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¨Ø­Ø« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…:\n' +
                    'â€¢ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…\n' +
                    'â€¢ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…\n' +
                    'â€¢ Ø±Ù‚Ù… Ø­Ø³Ø§Ø¨ 1xBet\n\n' +
                    'ğŸ” Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ø¨Ø­Ø«:'
                );
                break;

            case 'ğŸ”§ Ù‚ÙÙ„/ÙØªØ­ Ø§Ù„Ø¨ÙˆØª':
                await handleAdminToggleMaintenance(ctx);
                break;
                
            case 'ğŸ”™ Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† Ø§Ù„Ø¥Ø¯Ù…Ù†':
                ctx.session.adminMode = false;
                ctx.session.adminStep = null;
                await ctx.replyWithMarkdown('ğŸ”’ *ØªÙ… Ø§Ù„Ø®Ø±ÙˆØ¬ Ù…Ù† ÙˆØ¶Ø¹ Ø§Ù„Ø¥Ø¯Ù…Ù†*', { remove_keyboard: true });
                break;
                
            default:
                await ctx.replyWithMarkdown('âŒ *Ø®ÙŠØ§Ø± ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ*', getAdminMainKeyboard());
                break;
        }
    } catch (error) {
        console.error('Admin main error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ù…Ø±', getAdminMainKeyboard());
    }
}

// Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…
async function handleAdminSearchUser(ctx, query) {
    try {
        const users = await dbManager.searchUsers(query);
        
        if (users.length === 0) {
            await ctx.replyWithMarkdown('âŒ *Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†*', getAdminMainKeyboard());
            ctx.session.adminStep = 'main';
            return;
        }

        let message = `ğŸ” *Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ø¨Ø­Ø« (${users.length})*\n\n`;
        
        users.slice(0, 10).forEach((user, index) => {
            const status = user.subscription_status === 'active' ? 'âœ…' : 'ğŸ†“';
            message += `${index + 1}. ${user.username || 'Ø¨Ø¯ÙˆÙ† Ø§Ø³Ù…'} ${status}\n`;
            message += `   ğŸ‘¤ ${user.user_id} | ğŸ” ${user.onexbet}\n`;
            message += `   ğŸ“Š ${user.total_predictions || 0} ØªÙˆÙ‚Ø¹ | ğŸ’° ${user.total_profit || 0}$\n\n`;
        });

        if (users.length > 10) {
            message += `... Ùˆ ${users.length - 10} Ù…Ø³ØªØ®Ø¯Ù… Ø¢Ø®Ø±`;
        }

        await ctx.replyWithMarkdown(message, getAdminMainKeyboard());
        ctx.session.adminStep = 'main';
        
    } catch (error) {
        console.error('Admin search user error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¨Ø­Ø«', getAdminMainKeyboard());
        ctx.session.adminStep = 'main';
    }
}

// Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ø¬Ù…Ø§Ø¹ÙŠ

async function handleAdminBroadcast(ctx, message) {
    try {
        const users = await dbManager.getAllUsers();
        let success = 0;
        let failed = 0;

        const broadcastMsg = await ctx.replyWithMarkdown('ğŸ“¢ *Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†...*');

        for (const user of users) {
            const targetId = (user.user_id && user.user_id.toString()) || (user.id && user.id.toString());
            if (!targetId) { failed++; continue; }

            try {
                await bot.telegram.sendMessage(
                    targetId,
                    `ğŸ“¢ *Ø¥Ø´Ø¹Ø§Ø± Ù…Ù† Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©*\n\n${message}`,
                    { parse_mode: 'Markdown' }
                );
                success++;
            } catch (error) {
                failed++;
                console.log(`Broadcast failed to ${targetId}:`, error && error.message ? error.message : error);
            }

            await new Promise(resolve => setTimeout(resolve, 120));
        }

        await ctx.replyWithMarkdown(
            `ğŸ“¢ *ØªÙ… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡ Ù…Ù† Ø§Ù„Ø¥Ø±Ø³Ø§Ù„*\n\n` +
            `âœ… ØªÙ… Ø§Ù„Ø¥Ø±Ø³Ø§Ù„ Ø¨Ù†Ø¬Ø§Ø­: ${success} Ù…Ø³ØªØ®Ø¯Ù…\n` +
            `âŒ ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: ${failed} Ù…Ø³ØªØ®Ø¯Ù…\n` +
            `ğŸ‘¥ Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: ${users.length} Ù…Ø³ØªØ®Ø¯Ù…`,
            getAdminMainKeyboard()
        );

        ctx.session.adminStep = 'main';
    } catch (error) {
        console.error('Admin broadcast error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±', getAdminMainKeyboard());
        ctx.session.adminStep = 'main';
    }
}

//
async function handleAdminPriceEdit(ctx, text) {
    try {
        const parts = (text || '').trim().split(/\s+/);
        if (parts.length === 2 && ['week','month','three_months','year'].includes(parts[0])) {
            const key = parts[0];
            const val = parseFloat(parts[1]);
            if (isNaN(val) || val <= 0) {
                await ctx.replyWithMarkdown('âŒ Ù‚ÙŠÙ…Ø© ØºÙŠØ± ØµØ­ÙŠØ­Ø©. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø¥Ø±Ø³Ø§Ù„ Ø±Ù‚Ù… ØµØ§Ù„Ø­.');
                return;
            }
            const settings = await dbManager.getSettings();
            settings.prices = settings.prices || {};
            settings.prices[key] = val;
            await dbManager.updateSettings(settings);
            await ctx.replyWithMarkdown(`âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø³Ø¹Ø± ${key} Ø¥Ù„Ù‰ ${val}$`, getAdminSettingsKeyboard());
            ctx.session.adminStep = 'settings';
            return;
        }
        if (text && (text.toLowerCase().includes('send image') || text.toLowerCase().includes('ØµÙˆØ±Ù‡') || text.toLowerCase().includes('ØµÙˆØ±Ø©'))) {
            await ctx.replyWithMarkdown('ğŸ“¸ Ø£Ø±Ø³Ù„ ØµÙˆØ±Ø© ØªØ­ØªÙˆÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ø£Ø³Ø¹Ø§Ø± (Ø§Ù„Ø£Ø³Ø¨ÙˆØ¹ÙŠØŒ Ø§Ù„Ø´Ù‡Ø±ÙŠØŒ 3 Ø£Ø´Ù‡Ø±ØŒ Ø³Ù†ÙˆÙŠ). Ø³Ø£Ø­Ø§ÙˆÙ„ Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø§Ù„Ø£Ø±Ù‚Ø§Ù… Ø¹Ø¨Ø± OCR.');
            ctx.session.adminStep = 'price_edit';
            return;
        }
        await ctx.replyWithMarkdown('âŒ ØµÙŠØºØ© ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙØ©.\n\nÙ…Ø«Ø§Ù„ Ù„Ù„ØªØ¹Ø¯ÙŠÙ„: `week 15` Ø£Ùˆ Ø§ÙƒØªØ¨ "ØµÙˆØ±Ø©" Ø«Ù… Ø§Ø±Ø³Ù„ ØµÙˆØ±Ø© Ø§Ù„Ø£Ø³Ø¹Ø§Ø±.', { parse_mode: 'Markdown' });
    } catch (error) {
        console.error('handleAdminPriceEdit error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±', getAdminSettingsKeyboard());
        ctx.session.adminStep = 'settings';
    }
}

 Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø³Ø¹Ø§Ø±
async function handleAdminPriceEdit(ctx, text) {
    try {
        const parts = text.split(' ');
        if (parts.length !== 2) {
            await ctx.replyWithMarkdown('âŒ *ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!*\n\nØ§Ø³ØªØ®Ø¯Ù…: week 15 Ø£Ùˆ month 40 Ø¥Ù„Ø®...');
            return;
        }

        const [type, price] = parts;
        const priceNum = parseFloat(price);

        if (isNaN(priceNum) || priceNum <= 0) {
            await ctx.replyWithMarkdown('âŒ *Ø³Ø¹Ø± ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø³Ø¹Ø± Ø±Ù‚Ù… Ù…ÙˆØ¬Ø¨');
            return;
        }

        const validTypes = ['week', 'month', 'three_months', 'year'];
        if (!validTypes.includes(type)) {
            await ctx.replyWithMarkdown('âŒ *Ù†ÙˆØ¹ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nØ§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©: week, month, three_months, year');
            return;
        }

        const settings = await dbManager.getSettings();
        settings.prices[type] = priceNum;
        await dbManager.updateSettings(settings);

        await ctx.replyWithMarkdown(
            `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø³Ø¹Ø± Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
            `ğŸ“¦ ${type}: ${priceNum}$\n\n` +
            `ğŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª`,
            getAdminSettingsKeyboard()
        );

        ctx.session.adminStep = 'settings';
    } catch (error) {
        console.error('Admin price edit error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø³Ø¹Ø±', getAdminSettingsKeyboard());
    }
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±ÙˆØ§Ø¨Ø·
async function handleAdminLinkEdit(ctx, text) {
    try {
        const parts = text.split(' ');
        if (parts.length !== 2) {
            await ctx.replyWithMarkdown('âŒ *ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!*\n\nØ§Ø³ØªØ®Ø¯Ù…: week https://link.com Ø£Ùˆ month https://link.com Ø¥Ù„Ø®...');
            return;
        }

        const [type, link] = parts;

        const validTypes = ['week', 'month', 'three_months', 'year'];
        if (!validTypes.includes(type)) {
            await ctx.replyWithMarkdown('âŒ *Ù†ÙˆØ¹ ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nØ§Ù„Ø£Ù†ÙˆØ§Ø¹ Ø§Ù„Ù…Ø³Ù…ÙˆØ­Ø©: week, month, three_months, year');
            return;
        }

        if (!link.startsWith('http')) {
            await ctx.replyWithMarkdown('âŒ *Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¨Ù€ http Ø£Ùˆ https');
            return;
        }

        const settings = await dbManager.getSettings();
        settings.payment_links[type] = link;
        await dbManager.updateSettings(settings);

        await ctx.replyWithMarkdown(
            `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±Ø§Ø¨Ø· Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
            `ğŸ”— ${type}: ${link}\n\n` +
            `ğŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª`,
            getAdminSettingsKeyboard()
        );

        ctx.session.adminStep = 'settings';
    } catch (error) {
        console.error('Admin link edit error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø§Ø¨Ø·', getAdminSettingsKeyboard());
    }
}

// Ù…Ø¹Ø§Ù„Ø¬Ø© ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© QR
async function handleAdminQREdit(ctx, text) {
    try {
        if (!text.startsWith('qr ')) {
            await ctx.replyWithMarkdown('âŒ *ØµÙŠØºØ© ØºÙŠØ± ØµØ­ÙŠØ­Ø©!*\n\nØ§Ø³ØªØ®Ø¯Ù…: qr https://example.com/new-image.jpg');
            return;
        }

        const link = text.replace('qr ', '').trim();

        if (!link.startsWith('http')) {
            await ctx.replyWithMarkdown('âŒ *Ø±Ø§Ø¨Ø· ØºÙŠØ± ØµØ­ÙŠØ­!*\n\nÙŠØ¬Ø¨ Ø£Ù† ÙŠØ¨Ø¯Ø£ Ø§Ù„Ø±Ø§Ø¨Ø· Ø¨Ù€ http Ø£Ùˆ https');
            return;
        }

        // ØªØ­Ø¯ÙŠØ« Ø±Ø§Ø¨Ø· Ø§Ù„ØµÙˆØ±Ø© ÙÙŠ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
        const settings = await dbManager.getSettings();
        settings.analysis_image = link;
        await dbManager.updateSettings(settings);

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒÙˆÙ†ÙØ¬ Ø£ÙŠØ¶Ø§Ù‹
        CONFIG.ANALYSIS_IMAGE = link;

        await ctx.replyWithMarkdown(
            `âœ… *ØªÙ… ØªØ­Ø¯ÙŠØ« ØµÙˆØ±Ø© QR Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
            `ğŸ–¼ï¸ Ø§Ù„Ø±Ø§Ø¨Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯: ${link}\n\n` +
            `ğŸ”„ ØªÙ… Ø­ÙØ¸ Ø§Ù„ØªØºÙŠÙŠØ±Ø§Øª`,
            getAdminSettingsKeyboard()
        );

        ctx.session.adminStep = 'settings';
    } catch (error) {
        console.error('Admin QR edit error:', error);
        await ctx.replyWithMarkdown('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ¹Ø¯ÙŠÙ„ ØµÙˆØ±Ø© QR', getAdminSettingsKeyboard());
    }
}

async function handlePaymentAccept(ctx, paymentId) {
    try {
        const payment = await dbManager.getPayment(paymentId);
        if (!payment) {
            await ctx.answerCbQuery('âŒ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
            return;
        }
        
        const userData = await dbManager.getUser(payment.user_id);
        if (!userData) {
            await ctx.answerCbQuery('âŒ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
            return;
        }
        
        const startDate = new Date().toISOString();
        const endDate = addSubscriptionDays(startDate, payment.subscription_type);
        
        userData.subscription_status = 'active';
        userData.subscription_type = payment.subscription_type;
        userData.subscription_start_date = startDate;
        userData.subscription_end_date = endDate;
        userData.free_attempts = 0;
        
        await dbManager.saveUser(payment.user_id, userData);
        await dbManager.updatePayment(paymentId, { 
            status: 'accepted',
            processed_at: new Date().toISOString()
        });
        
        // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        try {
            await bot.telegram.sendMessage(
                payment.user_id,
                `ğŸ‰ *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ø´ØªØ±Ø§ÙƒÙƒ Ø¨Ù†Ø¬Ø§Ø­!*\n\n` +
                `âœ… ${payment.subscription_type}\n` +
                `ğŸ’° ${payment.amount}$\n` +
                `ğŸ“… Ø§Ù„Ø§Ù†ØªÙ‡Ø§Ø¡: ${new Date(endDate).toLocaleDateString('ar-EG')}\n` +
                `â³ Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ: ${calculateRemainingDays(endDate)} ÙŠÙˆÙ…\n\n` +
                `ğŸ¯ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„Ø¢Ù† Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø®Ø¯Ù…Ø© Ø¨Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Error notifying user:', error);
        }
        
        await ctx.answerCbQuery('âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ');
        
        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø­Ø°ÙÙ‡Ø§
        try {
            await ctx.editMessageText(
                `âœ… *ØªÙ… ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ø¨Ù†Ø¬Ø§Ø­*\n\n` +
                `ğŸ‘¤ ${userData.username}\n` +
                `ğŸ” ${userData.onexbet}\n` +
                `ğŸ“¦ ${payment.subscription_type}\n` +
                `ğŸ’° ${payment.amount}$\n\n` +
                `ğŸ•’ ${new Date().toLocaleString('ar-EG')}`,
                { parse_mode: 'Markdown' }
            );
        } catch (editError) {
            console.log('Could not edit message:', editError);
        }

    } catch (error) {
        console.error('Payment accept error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ù‚Ø¨ÙˆÙ„ Ø§Ù„Ø¯ÙØ¹');
    }
}

async function handlePaymentReject(ctx, paymentId) {
    try {
        const payment = await dbManager.getPayment(paymentId);
        if (!payment) {
            await ctx.answerCbQuery('âŒ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
            return;
        }
        
        await dbManager.updatePayment(paymentId, { 
            status: 'rejected',
            processed_at: new Date().toISOString()
        });
        
        // Ø¥Ø´Ø¹Ø§Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
        try {
            await bot.telegram.sendMessage(
                payment.user_id,
                `âŒ *ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹*\n\n` +
                `ğŸ’³ ÙŠØ±Ø¬Ù‰ Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµÙˆØ±Ø© Ø§Ù„Ø¯ÙØ¹ ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰\n\n` +
                `ğŸ“ Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±: ${CONFIG.DEVELOPER}`,
                { parse_mode: 'Markdown' }
            );
        } catch (error) {
            console.error('Error notifying user:', error);
        }
        
        await ctx.answerCbQuery('âŒ ØªÙ… Ø±ÙØ¶ Ø§Ù„Ø·Ù„Ø¨');
        
        // ØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø­Ø°ÙÙ‡Ø§
        try {
            await ctx.editMessageText(
                `âŒ *ØªÙ… Ø±ÙØ¶ Ø·Ù„Ø¨ Ø§Ù„Ø¯ÙØ¹*\n\n` +
                `ğŸ†” ${paymentId}\n` +
                `ğŸ‘¤ ${payment.username}\n` +
                `ğŸ” ${payment.onexbet}\n\n` +
                `ğŸ•’ ${new Date().toLocaleString('ar-EG')}`,
                { parse_mode: 'Markdown' }
            );
        } catch (editError) {
            console.log('Could not edit message:', editError);
        }

    } catch (error) {
        console.error('Payment reject error:', error);
        await ctx.answerCbQuery('âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¶ Ø§Ù„Ø¯ÙØ¹');
    }
}

// ğŸš€ START BOT
bot.launch().then(() => {
    console.log('ğŸ‰ SUCCESS! AI GOAL Predictor v10.4 is RUNNING!');
    console.log('ğŸ‘¤ Developer:', CONFIG.DEVELOPER);
    console.log('ğŸ“¢ Channel:', CONFIG.CHANNEL);
    console.log('ğŸŒ Health check: http://localhost:' + PORT);
    console.log('ğŸ”§ Admin ID:', CONFIG.ADMIN_ID);
}).catch(console.error);

// âš¡ Graceful shutdown
process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));

console.log('âœ… AI Goal Prediction System Ready!');